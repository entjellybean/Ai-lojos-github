package agent;
import lejos.hardware.Button;

import lejos.utility.Delay;
import action.Deplacement;
import action.Pince;
import perception.BoutonConsole;
import perception.ColorSensor;
import perception.MoveScan;

public class MainClass {
	private Deplacement mouvementRobot;
	//private Pince pince;
	private ColorSensor colorSensor;
	private BoutonConsole boutonConsole;
	//private MoveScan moveScan;
	private boolean isFirstPalletPicked = false;
	private boolean isSecondPalletPicked = false;
	private int positionRobotEnFace;

	public MainClass() {
		mouvementRobot = new Deplacement();
		//pince = new Pince();
		colorSensor = new ColorSensor();
		boutonConsole = new BoutonConsole();
		//moveScan = new MoveScan(); 
	}

	public static void main(String[] args) {
		MainClass robot = new MainClass();
		robot.start();
	}

	public void start() {
		System.out.println("wait...");
		positionRobotEnFace = boutonConsole.positionRobot();

		/*while (Button.ESCAPE.isUp()) {
			if (!isFirstPalletPicked) {
				mouvementRobot.avancerVers1erPalet();
				if (truetakePallet()) {
					mouvementRobot.pivoterDroite(90);
					mouvementRobot.avancerDe(24);
					mouvementRobot.pivoterGauche(90);
					goToWhiteLineAndDrop();
					isFirstPalletPicked = true;
				}
				//pince.lacher();
			} else if(!isSecondPalletPicked) {
				goToSecondPalletAndPick();
				isSecondPalletPicked = true;
			} else{
				searchAndCollectNextPallet();
			}
		}*/
		mouvementRobot.moveForward();
		//System.out.println(positionRobotEnFace);
		System.out.println("stop.");
		Delay.msDelay(2000);
		cleanup();
	}

	private boolean takePallet() { 
		// c'est la pince qu'il faut utiliser pour utiliser la méthode récupérer palet
		//return pince.recupererPalet();
		return false;
	}

	private void goToWhiteLineAndDrop() {
		while (!colorSensor.detecteLigneBlanche()) { //regarder quand ça s'arrête
			mouvementRobot.avancerDe(25); 
			if (detectObstacle()) { 
				eviterObstacle();
			}
		}
		//pince.lacherPalet();
	}



	private void goToSecondPalletAndPick() {

		//on suppose qu'on est au milieu du rectangle
		//s'orienter vers le palet qui n'a pas bougé en fonction de "position"
		if (positionRobotEnFace == 0) {
			//si le robot est à gauche
			//-(90+61,846)=-151,846
			mouvementRobot.pivoterGauche(151);
			mouvementRobot.setOrientation(-151);

		} else if (positionRobotEnFace == 1) {
			//si le robot est au milieu
			//(90+61,846)=151,846
			mouvementRobot.pivoterDroite(151);
			mouvementRobot.setOrientation(151);
		} else if (positionRobotEnFace == 2) {
			//si le robot est à droite
			//(90+61,846)=151,846
			mouvementRobot.pivoterGauche(151);
			mouvementRobot.setOrientation(-151);
		}
		//aller vers le palet
		mouvementRobot.avancerDe(62);
		takePallet();

		//aller à la ligne blanche
		if (positionRobotEnFace == 0) {
			//si le robot est à gauche
			//-(90+61,846)=-151,846
			mouvementRobot.pivoterDroite(151);
			mouvementRobot.setOrientation(0);

		} else if (positionRobotEnFace == 1) {
			//si le robot est au milieu
			//(90+61,846)=151,846
			mouvementRobot.pivoterGauche(151);
			mouvementRobot.setOrientation(0);
		} else if (positionRobotEnFace == 2) {
			//si le robot est à droite
			//(90+61,846)=151,846
			mouvementRobot.pivoterDroite(151);
			mouvementRobot.setOrientation(0);
		}
		mouvementRobot.avancerDe(56);
		while(!colorSensor.detecteLigneBlanche()){
			mouvementRobot.avancerDe(1);
		}
		//pince.lacherPalet();

	}

	private void searchAndCollectNextPallet() {

		//Faire un 360 pour détecter un palet

		/*if(){
//Si on ne trouve pas de palet
}*/


	}


	private boolean detectObstacle() { // tester la classe + changer la méthode pour avoir la distance en face
		/*if (moveScan.getCurrentDistance()>=25){
			return false;
		}
		return true;*/
		return false;
	}

	private void eviterObstacle() {
		//à vérifier si on détecte le mur
		/*boolean b = true;
		int cpt=0;
		float distanceObstacle = moveScan.getCurrentDistance();
		while(b){
			mouvementRobot.pivoterDroite(10);
			cpt+=10;
			if (!detectObstacle()){
				b = false;
			}
		}
		int avancer = (int) Math.sqrt(Math.pow(distanceObstacle,2)+225);
		mouvementRobot.avancerDe(avancer);
		mouvementRobot.pivoterGauche(cpt);
		mouvementRobot.avancerDe(avancer);

		 */
	}

	private void cleanup() {
		mouvementRobot.arretImmediat();
		//moveScan.close();
		colorSensor.close(); //créer la méthode close() pour colorSensor
		//pince.close();
	}
}
